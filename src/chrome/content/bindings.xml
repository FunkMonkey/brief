<?xml version="1.0"?>

<!DOCTYPE bindings SYSTEM "chrome://brief/locale/brief.dtd">

<bindings id="brief"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:html="http://www.w3.org/1999/xhtml">

    <binding id="feedentry">
        <content>
            <html:div class="article-header">
                <html:div class="expand-button"/>
                <html:div class="star-container">
                    <xul:image class="star-image"/>
                </html:div>
                <html:div class="article-controls">
                    <xul:button anonid="mark-read" class="mark-read"/>
                    <xul:button anonid="delete-entry" class="delete-entry"/>
                    <xul:button anonid="restore-entry" class="restore-entry"/>
                </html:div>
                <html:a anonid="article-title-link" class="article-title-link"/>
            </html:div>

            <html:div class="article-subheader">
                <html:div class="article-date"/>
                <html:div class="article-authors"/>
                <html:div class="feed-name"/>
            </html:div>

            <html:div class="article-content"/>
            <children/>
        </content>

        <implementation>
            <constructor>
            <![CDATA[
                // See comment in FeedView.buildFeedView() in feedview.js.
                window.XMLHttpRequest = null;

                // Get the data passed to us through attributes
                var entryURL = this.getAttribute('entryURL');
                var title    = this.getAttribute('entryTitle');
                var content  = this.getAttribute('content');
                var date     = new Date(parseInt(this.getAttribute('date')));
                var isRead   = this.getAttribute('read');
                var feedName = this.getAttribute('feedName');
                var authors  = this.getAttribute('authors');

                // Find elements
                var feedContentElement = document.getElementById('feed-content');
                var feedNameElement =
                    document.getAnonymousElementByAttribute(this, 'class', 'feed-name');
                var authorsElement =
                    document.getAnonymousElementByAttribute(this, 'class', 'article-authors');
                var titleElement =
                    document.getAnonymousElementByAttribute(this, 'class', 'article-title-link');
                var dateElement =
                    document.getAnonymousElementByAttribute(this, 'class', 'article-date');
                var articleContentElement =
                    document.getAnonymousElementByAttribute(this, 'class', 'article-content');
                var markReadButton =
                    document.getAnonymousElementByAttribute(this, 'class', 'mark-read');

                // Construct elements' contents from feed entry data. Use innerHTML
                // instead of textContent, so that the entities are resolved.
                titleElement.setAttribute('href', entryURL);
                titleElement.innerHTML = title;

                if (feedContentElement.hasAttribute('showFeedNames'))
                    feedNameElement.innerHTML = feedName;

                if (date > 0) {
                    var dateString = date.toLocaleString();
                    // Trim the seconds part.
                    dateString = dateString.substring(0, dateString.length - 3);
                    if (this.hasAttribute('updated'))
                        dateString = this.getAttribute('updated') + ' ' + dateString;

                    dateElement.innerHTML = dateString;
                }

                if (authors)
                    authorsElement.innerHTML = authors;

                articleContentElement.innerHTML = content;

                markReadButton.label = isRead ? feedContentElement.getAttribute('markUnreadString')
                                              : feedContentElement.getAttribute('markReadString');
            ]]>
            </constructor>

            <method name="toggleReadStatus">
                <body>
                <![CDATA[
                    if (this.hasAttribute('read'))
                        this.removeAttribute('read');
                    else
                        this.setAttribute('read', 'true');

                    var evt = document.createEvent('Events');
                    evt.initEvent('MarkEntryRead', false, false);

                    // Do the rest after timout for immediate visual feedback.
                    var self = this;
                    setTimeout(function() {self.dispatchEvent(evt)}, 0);
                ]]>
                </body>
            </method>

        </implementation>

        <handlers>
            <handler event="command">
            <![CDATA[
                var anonid = event.originalTarget.getAttribute('anonid');
                switch (anonid) {
                case 'mark-read':
                    this.toggleReadStatus();
                    break;

                case 'delete-entry':
                    var evt = document.createEvent('Events');
                    evt.initEvent('DeleteEntry', false, false);
                    this.dispatchEvent(evt);
                    break;

                case 'restore-entry':
                  var evt = document.createEvent('Events');
                    evt.initEvent('RestoreEntry', false, false);
                    this.dispatchEvent(evt);
                    break;
                }
            ]]>
            </handler>

            <handler event="click" button="0">
            <![CDATA[
                var target = event.originalTarget;

                if (target.className == 'star-container' || target.className == 'star-image') {
                    if (this.hasAttribute('starred'))
                        this.removeAttribute('starred');
                    else
                        this.setAttribute('starred', 'true');

                    var evt = document.createEvent('Events');
                    evt.initEvent('StarEntry', false, false);

                    // Do the rest after timout for immediate visual feedback.
                    var self = this;
                    setTimeout(function() {self.dispatchEvent(evt)}, 0);
                    return;
                }

                var articleContent = document.getAnonymousElementByAttribute(this, 'class',
                                                                      'article-content');
                var feedContent = document.getElementById('feed-content');
                if (this.hasAttribute('collapsed')) {
                    if (target.className != 'article-title-link' &&
                       target.className != 'article-controls' &&
                       target.parentNode.className != 'article-controls') {
                        $(articleContent).slideDown('fast');
                        this.removeAttribute('collapsed');
                    }
                }
                else {
                    if (target.className == 'expand-button' || (target.className == 'article-header' &&
                       feedContent.hasAttribute('showHeadlinesOnly'))) {
                        var self = this;
                        $(articleContent).slideUp('fast',
                                                  function(){ self.setAttribute('collapsed', true) });
                    }
                }
            ]]>
            </handler>

            <!-- Double-click marks the entry as read/unread -->
            <handler event="click" button="0" clickcount="2">
            <![CDATA[
                var feedContentDiv = document.getElementById('feed-content');
                if (!feedContentDiv.hasAttribute('doubleClickMarks'))
                    return;

                // If double-click happened in the article controls, do nothing
                // since it's too easy to trigger that accidentally.
                var target = event.originalTarget;
                while (target != this) {
                    if (target.className == 'article-controls' ||
                        target.className == 'star-container')
                        return;
                    target = target.parentNode;
                }

                this.toggleReadStatus();
            ]]>
            </handler>

            <handler event="DOMAttrModified">
            <![CDATA[
                switch (event.attrName) {
                case 'read':
                    var markReadButton = document.
                               getAnonymousElementByAttribute(this, 'class', 'mark-read');
                    var feedContentDiv = document.getElementById('feed-content');

                    if (event.newValue == 'true') {
                        markReadButton.label = feedContentDiv.getAttribute('markUnreadString');
                        if (this.hasAttribute('updated')) {
                            this.removeAttribute('updated');

                            var date = new Date(parseInt(this.getAttribute('date')));
                            var dateString = date.toLocaleString();
                            dateString = dateString.substring(0, dateString.length - 3);
                            var dateElement = document.getAnonymousElementByAttribute(
                                                            this, 'class', 'article-date');
                            dateElement.innerHTML = dateString;
                        }
                    }
                    else {
                        markReadButton.label = feedContentDiv.getAttribute('markReadString');
                    }
                    break;

                case 'collapsed':
                    var content = document.
                                  getAnonymousElementByAttribute(this, 'class', 'article-content');

                    // If an entry was (un)folded using jQuery, then changing
                    // the "collapsed" attribute alone isn't enough, because it
                    // doesn't (un)fold article-content.
                    if (event.newValue == 'true')
                        $(content).hide();
                    else
                        $(content).show();

                    break;
                }
            ]]>
            </handler>

            <handler event="RemoveEntry">
            <![CDATA[
                $(this).fadeOut(300);
                var self = this;
                var feedContent = document.getElementById('feed-content');
                setTimeout(function() { feedContent.removeChild(self); }, 300);
            ]]>
            </handler>

            <handler event="CollapseEntry">
            <![CDATA[
                var articleContent = document.getAnonymousElementByAttribute(this, 'class',
                                                                          'article-content');
                if (this.hasAttribute('collapsed')) {
                    $(articleContent).slideDown('fast');
                    this.removeAttribute('collapsed');
                }
                else {
                    var self = this;
                    function collapse() {
                        self.setAttribute('collapsed', true);
                    }
                    $(articleContent).slideUp('fast', collapse);
                }
            ]]>
            </handler>
        </handlers>
    </binding>


    <binding id="searchbar"
             extends="chrome://global/content/bindings/textbox.xml#timed-textbox">
        <content>
            <children/>
            <xul:hbox class="searchbar-textbox textbox-input-box" flex="1">
                <xul:button class="search-scope-button" popup="_child"
                            tooltiptext="&searchScopeButton.tooltip;">
                    <xul:menupopup anonid="searchbar-popup" position="after_start">
                          <xul:menuitem anonid="search-current"
                                        label="&searchCurrentView.label;"
                                        type="radio"
                                        value="0"/>
                          <xul:menuitem anonid="search-all"
                                        label="&searchAllFeeds.label;"
                                        type="radio"
                                        value="1"/>
                    </xul:menupopup>
                    <xul:image class="searchbar-button-image"/>
                </xul:button>

                <html:input class="searchbar-textbox textbox-input" anonid="input"
                            allowevents="true"
                            flex="1"
                            xbl:inherits="onfocus,onblur,value,type,maxlength,disabled,size,readonly,tabindex,accesskey"/>
            </xul:hbox>

            <xul:toolbarbutton anonid="searchbar-clearbutton"
                               class="searchbar-clearbutton"
                               hidden="true"/>
        </content>
        <implementation>
            <constructor>
            <![CDATA[
                this.clearButton = document.getAnonymousElementByAttribute(this, 'anonid',
                                                               'searchbar-clearbutton');
                var menuitem = document.getAnonymousElementByAttribute(this, 'value',
                                                           this.searchScope.toString());
                menuitem.setAttribute('checked', true);
                this.setAttribute('showingDescription', true);
            ]]>
            </constructor>

            <field name="clearButton">
              null
            </field>
            <property name="searchScope"
                      onget="return this.getAttribute('searchScope');">
                <setter>
                <![CDATA[
                    if (val != this.searchScope) {
                        this.setAttribute('searchScope', val.toString());
                        if (!this.hasAttribute('showingDescription') && this.value)
                            performSearch();
                    }
                    return val;
                ]]>
                </setter>
            </property>
            <method name="clear">
                <body>
                <![CDATA[
                    this.value = '';
                    this.clearButton.hidden = true;
                    performSearch();
                    this.inputField.blur();
                ]]>
                </body>
            </method>

        </implementation>

        <handlers>
            <handler event="command">
            <![CDATA[
                var target = event.originalTarget;
                var anonid = target.getAttribute('anonid');
                var textbox = document.getBindingParent(target);

                if (anonid == 'search-current' || anonid == 'search-all') {
                    if (textbox.hasAttribute('showingDescription'))
                        textbox.value = target.label;
                    textbox.searchScope = target.value;
                }

                else if (target.id == 'searchbar') {
                    performSearch();
                }

                else if (anonid == 'searchbar-clearbutton') {
                    this.clear();
                }
            ]]>
            </handler>
            <handler event="focus" phase="capturing">
            <![CDATA[
                if (event.target.hasAttribute('showingDescription'))
                    event.target.removeAttribute('showingDescription');
            ]]>
            </handler>
            <handler event="blur" phase="capturing">
            <![CDATA[
                var target = event.target;
                if (!target.value)
                    target.setAttribute('showingDescription', true);
            ]]>
            </handler>
            <handler event="input">
            <![CDATA[
                this.clearButton.hidden = !this.value;
            ]]>
            </handler>
            <handler event="DOMAttrModified">
            <![CDATA[
                if (event.attrName == 'showingDescription') {
                    if (event.target.hasAttribute('showingDescription')) {
                        var menuitem = document.getAnonymousElementByAttribute(this, 'value',
                                                               this.searchScope.toString());
                        this.value = menuitem.label;
                        this.clearButton.hidden = true;
                    }
                    else
                        event.target.value = '';
                }
            ]]>
            </handler>
            <handler event="keydown" keycode="VK_ESCAPE">
            <![CDATA[
                this.clear();
                event.preventDefault();
            ]]>
            </handler>
        </handlers>
    </binding>


    <!-- Copied over from tree.xml. We have to copy the entire binding just to
         overwrite the mousedown handler. -->
    <binding id="feedlist-treebody"
             extends="chrome://global/content/bindings/tree.xml#tree-base">
      <implementation>
        <constructor>
          if ("_ensureColumnOrder" in this.parentNode)
            this.parentNode._ensureColumnOrder();
        </constructor>

        <field name="_lastSelectedRow">
          -1
        </field>
      </implementation>
      <handlers>
        <!-- If there is no modifier key, we select on mousedown, not
             click, so that drags work correctly. -->
        <handler event="mousedown" clickcount="1">
        <![CDATA[
           if (event.button == 0) {
             var row = {};
             var col = {};
             var obj = {};
             var b = this.parentNode.treeBoxObject;
             b.getCellAt(event.clientX, event.clientY, row, col, obj);

             // save off the last selected row
             this._lastSelectedRow = row.value;
             if (row.value == -1)
               return;

            var item = this.parentNode.view.getItemAtIndex(row.value);
            if (item.localName == 'treeseparator')
              return;

             if (col.value && obj.value != "twisty") {
               if (col.value.cycler)
                 b.view.cycleCell(row.value, col.value);
               else if (col.value.type == Components.interfaces.nsITreeColumn.TYPE_CHECKBOX) {
                 if (this.parentNode.editable && col.value.editable &&
                     b.view.isEditable(row.value, col.value)) {
                   var value = b.view.getCellValue(row.value, col.value);
                   value = value == "true" ? "false" : "true";
                   b.view.setCellValue(row.value, col.value, value);
                 }
               }
               else
                 if (!b.view.selection.isSelected(row.value)) {
                   b.view.selection.select(row.value);
                   b.ensureRowIsVisible(row.value);
                 }
             }
           }
        ]]>
        </handler>

        <!-- On a click (up+down on the same item), deselect everything
             except this item. -->
        <handler event="click" button="0" clickcount="1">
        <![CDATA[
          var row = {};
          var col = {};
          var obj = {};
          var b = this.parentNode.treeBoxObject;
          b.getCellAt(event.clientX, event.clientY, row, col, obj);

          if (row.value == -1)
            return;

          var item = this.parentNode.view.getItemAtIndex(row.value);
          if (item.localName == 'treeseparator')
            return;

          if (obj.value == "twisty") {
            if (b.view.selection.currentIndex >= 0 &&
                b.view.isContainerOpen(row.value)) {
              var parentIndex = b.view.getParentIndex(b.view.selection.currentIndex);
              while (parentIndex >= 0 && parentIndex != row.value)
                parentIndex = b.view.getParentIndex(parentIndex);
              if (parentIndex == row.value)
                b.view.selection.select(parentIndex);
            }
            this.parentNode.changeOpenState(row.value);
            return;
          }

          if (! b.view.selection.single) {
            var augment = this._isAccelPressed(event);
            if (event.shiftKey) {
              b.view.selection.rangedSelect(-1, row.value, augment);
              b.ensureRowIsVisible(row.value);
              return;
            }
            if (augment) {
              b.view.selection.toggleSelect(row.value);
              b.ensureRowIsVisible(row.value);
              b.view.selection.currentIndex = row.value;
              return;
            }
          }

          /* We want to deselect all the selected items except what was
            clicked, UNLESS it was a right-click.  We have to do this
            in click rather than mousedown so that you can drag a
            selected group of items */

          if (!col.value) return;

          // if the last row has changed in between the time we
          // mousedown and the time we click, don't fire the select handler.
          // see bug #92366
          if (!col.value.cycler && this._lastSelectedRow == row.value &&
              col.value.type != Components.interfaces.nsITreeColumn.TYPE_CHECKBOX) {
            b.view.selection.select(row.value);
            b.ensureRowIsVisible(row.value);
          }
        ]]>
        </handler>

        <!-- double-click -->
        <handler event="click" clickcount="2">
        <![CDATA[
          var b = this.parentNode.treeBoxObject;
          var row = b.view.selection.currentIndex;
          if (row == -1 || !b.view.isContainer(row))
            return;

           var col = {};
           var obj = {};
           b.getCellAt(event.clientX, event.clientY, {}, col, obj);

           // Cyclers and twisties respond to single clicks, not double clicks
           if (!col.value.cycler && obj.value != "twisty")
             this.parentNode.changeOpenState(row);
        ]]>
        </handler>

      </handlers>
    </binding>

</bindings>
<?xml version="1.0"?>

<!DOCTYPE bindings SYSTEM "chrome://brief/locale/brief.dtd">

<bindings id="brief"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:html="http://www.w3.org/1999/xhtml">

<binding id="feedentry">
    <content>
        <html:div class="article-header">
            <html:div class="expand-button"/>
            <html:div class="star-article" command="switchStarred"/>
            <html:div class="article-controls">
                <html:div class="mark-read" command="switchRead">
                    <html:div class="mark-read-left" command="switchRead"/>
                    <html:div class="mark-read-centre" command="switchRead"/>
                    <html:div class="mark-read-right" command="switchRead"/>
                </html:div>
                <html:div class="delete-entry" command="delete"/>
                <html:div class="restore-entry" command="restore"/>
            </html:div>
            <html:a class="article-title-link" command="open"/>
        </html:div>

        <html:div class="article-subheader">
            <html:div class="article-date"/>
            <html:div class="article-authors"/>
            <html:div class="feed-name"/>
        </html:div>

        <html:div class="article-content"/>
        <children/>
    </content>

    <implementation>
        <constructor>
            <![CDATA[
            // Find elements
            var feedNameElem = this.getElement('feed-name');
            var authorsElem  = this.getElement('article-authors');
            var titleElem    = this.getElement('article-title-link');
            var dateElem     = this.getElement('article-date');
            var contentElem  = this.getElement('article-content');
            var markReadElem = this.getElement('mark-read-centre');

            // Use innerHTML instead of textContent, so that the entities are resolved.
            titleElem.setAttribute('href', this.getAttribute('entryURL'));
            titleElem.innerHTML = this.getAttribute('entryTitle');

            var feedContent = document.getElementById('feed-content');
            if (feedContent.hasAttribute('showFeedNames'))
                feedNameElem.innerHTML = this.getAttribute('feedName');

            dateElem.innerHTML = this.getAttribute('updated') || this.getAttribute('date');
            authorsElem.innerHTML = this.getAttribute('authors');
            contentElem.innerHTML = this.getAttribute('content');
            markReadElem.textContent = this.read ? gConveyedData.markUnreadString
                                                 : gConveyedData.markReadString;

            if (this.collapsed) {
                $(contentElem).hide();
                var headerElem = this.getElement('article-header');
                headerElem.insertBefore(feedNameElem, titleElem);
                headerElem.insertBefore(dateElem, titleElem);
            }
            ]]>
        </constructor>

        <method name="getElement">
            <parameter name="aClassName"/>
            <body>
                return document.getAnonymousElementByAttribute(this, 'class', aClassName);
            </body>
        </method>

        <method name="sendEvent">
            <parameter name="aEventName"/>
            <parameter name="aAsync"/>
            <body>
                var evt = document.createEvent('Events');
                evt.initEvent(aEventName, false, false);
                if (aAsync) {
                    var self = this;
                    setTimeout(function() { self.dispatchEvent(evt) }, 0);
                }
                else {
                    this.dispatchEvent(evt);
                }
            </body>
        </method>

        <method name="collapse">
            <parameter name="aState"/>
            <parameter name="aAnimate"/>
            <body>
                <![CDATA[
                if (aState == this.collapsed)
                    return;

                var articleContent = this.getElement('article-content');
                var feedName = this.getElement('feed-name');
                var date = this.getElement('article-date');
                var self = this;

                if (aState) {
                    function finish() {
                        self.setAttribute('collapsed', true);

                        var title = self.getElement('article-title-link');
                        var header = self.getElement('article-header');
                        header.insertBefore(feedName, title);
                        header.insertBefore(date, title);
                    }

                    if (aAnimate) {
                        $(articleContent).slideUp(200, finish);
                    }
                    else {
                        $(articleContent).hide();
                        finish();
                    }
                }

                else {
                    this.removeAttribute('collapsed');

                    var subheader = self.getElement('article-subheader');
                    var authors = self.getElement('article-authors');
                    subheader.appendChild(feedName);
                    subheader.insertBefore(date, authors);

                    function finish() {
                        self.sendEvent('EntryUncollapsed');
                    }

                    if (aAnimate) {
                        $(articleContent).slideDown(200, finish);
                    }
                    else {
                        $(articleContent).show();
                        finish();
                    }
                }
                ]]>
            </body>
        </method>


        <property name="read"
                  onget="return this.hasAttribute('read')">
            <setter>
                <![CDATA[
                if (val == this.read)
                    return;

                var markReadButton = this.getElement('mark-read-centre');

                if (val) {
                    this.setAttribute('read', 'true');
                    markReadButton.textContent = gConveyedData.markUnreadString;

                    if (this.hasAttribute('updated')) {
                        this.removeAttribute('updated');
                        var dateElement = this.getElement('article-date');
                        dateElement.innerHTML = this.getAttribute('date');
                    }
                }

                else {
                    this.removeAttribute('read');
                    markReadButton.textContent = gConveyedData.markReadString;
                }

                return val;
                ]]>
            </setter>
        </property>

        <property name="starred"
                  onget="return this.hasAttribute('starred')">
            <setter>
                if (val)
                    this.setAttribute('starred', 'true');
                else
                    this.removeAttribute('starred');

                return val;
            </setter>
        </property>

        <property name="collapsed"
                  onget="return this.hasAttribute('collapsed')"/>

    </implementation>

    <handlers>
        <handler event="click" button="0">
            <![CDATA[
            var target = event.originalTarget;
            var command = target.getAttribute('command');

            if (command) {
                switch (command) {
                    case 'switchRead':
                        this.read = !this.read;
                        this.sendEvent('SwitchEntryRead', true);
                        break;
                    case 'switchStarred':
                        this.starred = !this.starred;
                        this.sendEvent('SwitchEntryStarred');
                        break;
                    case 'delete':
                        this.sendEvent('DeleteEntry');
                        break;
                    case 'restore':
                        this.sendEvent('RestoreEntry');
                        break;
                }
            }

            else if (this.collapsed) {
                if (!target.hasAttribute(command))
                    this.collapse(false, true);
            }

            else {
                var headlinesView = document.getElementById('feed-content').
                                             hasAttribute('showHeadlinesOnly');
                var cls = target.className;

                if (headlinesView && (cls == 'expand-button' || cls == 'article-header'))
                    this.collapse(true, true);
            }
            ]]>
        </handler>


        <!-- Double-click marks the entry as read/unread. If the click targeted a
             command element, do nothing since it's too easy to do it accidentally.-->
        <handler event="click" button="0" clickcount="2">
            <![CDATA[
            var isCommandElement = event.originalTarget.hasAttribute('command');

            if (gConveyedData.doubleClickMarks && !isCommandElement) {
                this.read = !this.read;
                this.sendEvent('SwitchEntryRead', true);
            }
            ]]>
        </handler>


        <!-- This event is how chrome sends us messages -->
        <handler event="ViewEvent">
            <![CDATA[
            var state = (this.getAttribute('eventState') == 'true');
            switch (this.getAttribute('eventType')) {
                case 'EntryMarkedRead':
                    this.read = state;
                    break;
                case 'EntryStarred':
                    this.starred = state;
                    break;
                case 'DoRemoveEntry':
                    var self = this;
                    function callback() {
                        var feedContent = document.getElementById('feed-content');
                        feedContent.removeChild(self);
                    }
                    $(this).fadeOut(300, callback);
                    break;
                case 'DoCollapseEntry':
                    this.collapse(state, false);
                    break;
                case 'DoCollapseEntryAnimated':
                    this.collapse(state, true);
                    break;
            }
            ]]>
        </handler>

    </handlers>
</binding>


<binding id="searchbar"
         extends="chrome://global/content/bindings/textbox.xml#timed-textbox">
    <content>
        <children/>
        <xul:hbox class="searchbar-textbox textbox-input-box" flex="1">
            <xul:button class="search-scope-button" popup="_child"
                        tooltiptext="&searchScopeButton.tooltip;">
                <xul:menupopup anonid="searchbar-popup" position="after_start">
                      <xul:menuitem anonid="search-current"
                                    label="&searchCurrentView.label;"
                                    type="radio"
                                    value="0"/>
                      <xul:menuitem anonid="search-all"
                                    label="&searchAllFeeds.label;"
                                    type="radio"
                                    value="1"/>
                </xul:menupopup>
                <xul:image class="searchbar-button-image"/>
            </xul:button>

            <html:input class="searchbar-textbox textbox-input" anonid="input"
                        allowevents="true"
                        flex="1"
                        xbl:inherits="onfocus,onblur,value,type,maxlength,disabled,size,readonly,tabindex,accesskey"/>
        </xul:hbox>

        <xul:toolbarbutton anonid="searchbar-clearbutton"
                           class="searchbar-clearbutton"
                           hidden="true"/>
    </content>
    <implementation>
        <constructor>
        <![CDATA[
            this.clearButton = document.getAnonymousElementByAttribute(this, 'anonid',
                                                           'searchbar-clearbutton');
            var menuitem = document.getAnonymousElementByAttribute(this, 'value',
                                                       this.searchScope.toString());
            menuitem.setAttribute('checked', true);
            this.setAttribute('showingDescription', true);
        ]]>
        </constructor>

        <field name="clearButton">
          null
        </field>
        <property name="searchScope"
                  onget="return this.getAttribute('searchScope');">
            <setter>
            <![CDATA[
                if (val != this.searchScope) {
                    this.setAttribute('searchScope', val.toString());
                    if (!this.hasAttribute('showingDescription') && this.value)
                        performSearch();
                }
                return val;
            ]]>
            </setter>
        </property>
        <method name="clear">
            <body>
            <![CDATA[
                this.value = '';
                this.clearButton.hidden = true;
                performSearch();
                this.inputField.blur();
            ]]>
            </body>
        </method>

    </implementation>

    <handlers>
        <handler event="command">
        <![CDATA[
            var target = event.originalTarget;
            var anonid = target.getAttribute('anonid');
            var textbox = document.getBindingParent(target);

            if (anonid == 'search-current' || anonid == 'search-all') {
                if (textbox.hasAttribute('showingDescription'))
                    textbox.value = target.label;
                textbox.searchScope = target.value;
            }

            else if (target.id == 'searchbar') {
                performSearch();
            }

            else if (anonid == 'searchbar-clearbutton') {
                this.clear();
            }
        ]]>
        </handler>
        <handler event="focus" phase="capturing">
        <![CDATA[
            if (event.target.hasAttribute('showingDescription'))
                event.target.removeAttribute('showingDescription');
        ]]>
        </handler>
        <handler event="blur" phase="capturing">
        <![CDATA[
            var target = event.target;
            if (!target.value)
                target.setAttribute('showingDescription', true);
        ]]>
        </handler>
        <handler event="input">
        <![CDATA[
            this.clearButton.hidden = !this.value;
        ]]>
        </handler>
        <handler event="DOMAttrModified">
        <![CDATA[
            if (event.attrName == 'showingDescription') {
                if (event.target.hasAttribute('showingDescription')) {
                    var menuitem = document.getAnonymousElementByAttribute(this, 'value',
                                                           this.searchScope.toString());
                    this.value = menuitem.label;
                    this.clearButton.hidden = true;
                }
                else
                    event.target.value = '';
            }
        ]]>
        </handler>
        <handler event="keydown" keycode="VK_ESCAPE">
        <![CDATA[
            this.clear();
            event.preventDefault();
        ]]>
        </handler>
    </handlers>
</binding>


<!-- Copied over from tree.xml. We have to copy the entire binding just to
     overwrite the mousedown handler. -->
<binding id="feedlist-treebody"
         extends="chrome://global/content/bindings/tree.xml#tree-base">
  <implementation>
    <constructor>
      if ("_ensureColumnOrder" in this.parentNode)
        this.parentNode._ensureColumnOrder();
    </constructor>

    <field name="_lastSelectedRow">
      -1
    </field>
  </implementation>
  <handlers>
    <!-- If there is no modifier key, we select on mousedown, not
         click, so that drags work correctly. -->
    <handler event="mousedown" clickcount="1">
    <![CDATA[
       if (event.button == 0) {
         var row = {};
         var col = {};
         var obj = {};
         var b = this.parentNode.treeBoxObject;
         b.getCellAt(event.clientX, event.clientY, row, col, obj);

         // save off the last selected row
         this._lastSelectedRow = row.value;
         if (row.value == -1)
           return;

        var item = this.parentNode.view.getItemAtIndex(row.value);
        if (item.localName == 'treeseparator')
          return;

         if (col.value && obj.value != "twisty") {
           if (col.value.cycler)
             b.view.cycleCell(row.value, col.value);
           else if (col.value.type == Components.interfaces.nsITreeColumn.TYPE_CHECKBOX) {
             if (this.parentNode.editable && col.value.editable &&
                 b.view.isEditable(row.value, col.value)) {
               var value = b.view.getCellValue(row.value, col.value);
               value = value == "true" ? "false" : "true";
               b.view.setCellValue(row.value, col.value, value);
             }
           }
           else
             if (!b.view.selection.isSelected(row.value)) {
               b.view.selection.select(row.value);
               b.ensureRowIsVisible(row.value);
             }
         }
       }
    ]]>
    </handler>

    <!-- On a click (up+down on the same item), deselect everything
         except this item. -->
    <handler event="click" button="0" clickcount="1">
    <![CDATA[
      var row = {};
      var col = {};
      var obj = {};
      var b = this.parentNode.treeBoxObject;
      b.getCellAt(event.clientX, event.clientY, row, col, obj);

      if (row.value == -1)
        return;

      var item = this.parentNode.view.getItemAtIndex(row.value);
      if (item.localName == 'treeseparator')
        return;

      if (obj.value == "twisty") {
        if (b.view.selection.currentIndex >= 0 &&
            b.view.isContainerOpen(row.value)) {
          var parentIndex = b.view.getParentIndex(b.view.selection.currentIndex);
          while (parentIndex >= 0 && parentIndex != row.value)
            parentIndex = b.view.getParentIndex(parentIndex);
          if (parentIndex == row.value)
            b.view.selection.select(parentIndex);
        }
        this.parentNode.changeOpenState(row.value);
        return;
      }

      if (! b.view.selection.single) {
        var augment = this._isAccelPressed(event);
        if (event.shiftKey) {
          b.view.selection.rangedSelect(-1, row.value, augment);
          b.ensureRowIsVisible(row.value);
          return;
        }
        if (augment) {
          b.view.selection.toggleSelect(row.value);
          b.ensureRowIsVisible(row.value);
          b.view.selection.currentIndex = row.value;
          return;
        }
      }

      /* We want to deselect all the selected items except what was
        clicked, UNLESS it was a right-click.  We have to do this
        in click rather than mousedown so that you can drag a
        selected group of items */

      if (!col.value) return;

      // if the last row has changed in between the time we
      // mousedown and the time we click, don't fire the select handler.
      // see bug #92366
      if (!col.value.cycler && this._lastSelectedRow == row.value &&
          col.value.type != Components.interfaces.nsITreeColumn.TYPE_CHECKBOX) {
        b.view.selection.select(row.value);
        b.ensureRowIsVisible(row.value);
      }
    ]]>
    </handler>

    <!-- double-click -->
    <handler event="click" clickcount="2">
    <![CDATA[
      var b = this.parentNode.treeBoxObject;
      var row = b.view.selection.currentIndex;
      if (row == -1 || !b.view.isContainer(row))
        return;

       var col = {};
       var obj = {};
       b.getCellAt(event.clientX, event.clientY, {}, col, obj);

       // Cyclers and twisties respond to single clicks, not double clicks
       if (!col.value.cycler && obj.value != "twisty")
         this.parentNode.changeOpenState(row);
    ]]>
    </handler>

  </handlers>
</binding>

</bindings>

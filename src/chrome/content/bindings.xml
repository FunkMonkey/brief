<?xml version="1.0"?>

<!DOCTYPE bindings SYSTEM "chrome://brief/locale/brief.dtd">

<bindings id="brief"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:html="http://www.w3.org/1999/xhtml">

<!-- We use a seperate binding for article-header instead of making its content
     a part of the article binding, because we need the article-header element to be
     explicit. If it is anonymous, then we get wacky layout bugs related to mixing
     the explicit article-content element with an anonymous one. Damn you, XBL. -->
<binding id="article-header">
    <xbl:content xmlns="http://www.w3.org/1999/xhtml">
        <div class="expand-button"/>
        <div class="star-article" command="switchStarred"/>

        <div class="article-controls">
            <div class="mark-read" command="switchRead">
                <div class="mark-read-left" command="switchRead"/>
                <div class="mark-read-centre" command="switchRead"/>
                <div class="mark-read-right" command="switchRead"/>
            </div>
            <div class="delete-entry" command="delete"/>
            <div class="restore-entry" command="restore"/>
        </div>

        <div class="collapsed-article-subheader"/>

        <xbl:children/>

        <div class="article-subheader">
            <div class="article-date"/>
            <div class="article-authors"/>
            <div class="feed-name"/>
            <div class="article-tags"/>
        </div>

    </xbl:content>
</binding>


<binding id="article">
    <implementation>
        <constructor>
            // Some feeds include scripts that use document.write() which screw us up,
            // because we insert them dynamically after the page is loaded.
            document.write = function() { };

            var header = document.createElement('div');
            header.className = 'article-header';
            this.appendChild(header);
            this.header = header;

            // Build the content of the header and the subheader. Use innerHTML
            // instead of textContent, so that the entities are resolved.
            var titleElem = document.createElement('a');
            titleElem.className = 'article-title-link';
            titleElem.setAttribute('href', this.getAttribute('entryURL'));
            titleElem.setAttribute('command', 'open');
            titleElem.innerHTML = this.getAttribute('entryTitle') ||
                                  this.getAttribute('entryURL');
            header.appendChild(titleElem);

            var feedContent = document.getElementById('feed-content');
            var feedNameElem = this.getElement('feed-name');
            if (feedContent.hasAttribute('showFeedNames'))
                feedNameElem.innerHTML = this.getAttribute('feedName');

            var dateElem = this.getElement('article-date');
            dateElem.innerHTML = this.getAttribute('updated') || this.getAttribute('date');

            var authorsElem = this.getElement('article-authors');
            authorsElem.innerHTML = this.getAttribute('authors');

            var tagsElem = this.getElement('article-tags');
            tagsElem.textContent = this.getAttribute('tags');

            var markReadElem = this.getElement('mark-read-centre');
            markReadElem.textContent = this.read ? gConveyedData.markUnreadString
                                                 : gConveyedData.markReadString;

            // article-content and article-title-link elements are created manually,
            // so that they are explicit instead of anynymous. This makes the context
            // menu work on them without the need of ugly and fragile hacks.
            // It also increases the chance of compatibility with various other
            // extensions which interact with the content.
            var contentElem = document.createElement('div');
            contentElem.className = 'article-content';
            contentElem.innerHTML = this.getAttribute('content');
            this.appendChild(contentElem);

            if (this.collapsed) {
                var collapsedSubheader = this.getElement('collapsed-article-subheader');
                collapsedSubheader.insertBefore(dateElem, null);
                collapsedSubheader.insertBefore(feedNameElem, null);
                $(contentElem).hide();
            }
        </constructor>

        <field name="header">
            null
        </field>

        <method name="getElement">
            <parameter name="aClassName"/>
            <body>
                return document.getAnonymousElementByAttribute(this.header, 'class',
                                                               aClassName);
            </body>
        </method>

        <method name="sendEvent">
            <parameter name="aEventName"/>
            <parameter name="aAsync"/>
            <body>
                var evt = document.createEvent('Events');
                evt.initEvent(aEventName, false, false);
                if (aAsync) {
                    var self = this;
                    setTimeout(function() { self.dispatchEvent(evt) }, 0);
                }
                else {
                    this.dispatchEvent(evt);
                }
            </body>
        </method>

        <method name="collapse">
            <parameter name="aState"/>
            <parameter name="aAnimate"/>
            <body>
                if (aState == this.collapsed)
                    return;

                var articleContent = this.getElementsByClassName('article-content')[0];
                var date = this.getElement('article-date');
                var feedName = this.getElement('feed-name');
                var self = this;

                if (aState) {
                    function finish() {
                        self.setAttribute('collapsed', true);

                        var collapsedSubheader = self.getElement('collapsed-article-subheader');
                        collapsedSubheader.insertBefore(date, null);
                        collapsedSubheader.insertBefore(feedName, null);
                    }

                    if (aAnimate) {
                        $(articleContent).animate({height: 'hide', opacity: 'hide'},
                                                  200, 'linear', finish);
                    }
                    else {
                        $(articleContent).hide();
                        finish();
                    }
                }

                else {
                    this.removeAttribute('collapsed');

                    var subheader = this.getElement('article-subheader');
                    subheader.insertBefore(date, this.getElement('article-authors'));
                    subheader.insertBefore(feedName, null);

                    function finish() {
                        self.sendEvent('EntryUncollapsed');
                    }

                    if (aAnimate) {
                        $(articleContent).animate({height: 'show', opacity: 'show'},
                                                  200, 'linear', finish);
                    }
                    else {
                        $(articleContent).show();
                        finish();
                    }
                }
            </body>
        </method>


        <property name="read"
                  onget="return this.hasAttribute('read')">
            <setter>
                if (val == this.read)
                    return;

                var markReadButton = this.getElement('mark-read-centre');

                if (val) {
                    this.setAttribute('read', 'true');
                    markReadButton.textContent = gConveyedData.markUnreadString;

                    if (this.hasAttribute('updated')) {
                        this.removeAttribute('updated');
                        var dateElement = this.getElement('article-date');
                        dateElement.innerHTML = this.getAttribute('date');
                    }
                }

                else {
                    this.removeAttribute('read');
                    markReadButton.textContent = gConveyedData.markReadString;
                }

                return val;
            </setter>
        </property>

        <property name="starred"
                  onget="return this.hasAttribute('starred')">
            <setter>
                if (val)
                    this.setAttribute('starred', 'true');
                else
                    this.removeAttribute('starred');

                return val;
            </setter>
        </property>

        <property name="collapsed"
                  onget="return this.hasAttribute('collapsed')"/>

    </implementation>

    <handlers>
        <handler event="click" button="0">
            <![CDATA[
            var target = event.originalTarget;
            var command = target.getAttribute('command');

            if (command) {
                switch (command) {
                case 'switchRead':
                    this.sendEvent('SwitchEntryRead');
                    break;
                case 'switchStarred':
                    this.sendEvent('SwitchEntryStarred');
                    break;
                case 'delete':
                    this.sendEvent('DeleteEntry');
                    break;
                case 'restore':
                    this.sendEvent('RestoreEntry');
                    break;
                }
            }
            else if (this.collapsed) {
                if (!target.hasAttribute(command))
                    this.collapse(false, true);
            }
            else {
                var headlinesView = document.getElementById('feed-content').
                                             hasAttribute('showHeadlinesOnly');
                var cls = target.className;

                if (headlinesView && (cls == 'expand-button' || cls == 'article-header'))
                    this.collapse(true, true);
            }
            ]]>
        </handler>


        <!-- Double-click marks the entry as read/unread. If the click targeted a
             command element, do nothing since it's too easy to do it accidentally.-->
        <handler event="click" button="0" clickcount="2">
            <![CDATA[
            var isCommandElement = event.originalTarget.hasAttribute('command');

            if (gConveyedData.doubleClickMarks && !isCommandElement) {
                this.read = !this.read;
                this.sendEvent('SwitchEntryRead', true);
            }
            ]]>
        </handler>


        <!-- This event is how chrome sends us messages -->
        <handler event="ViewEvent">
            var state = (this.getAttribute('eventState') == 'true');
            switch (this.getAttribute('eventType')) {
                case 'EntryMarkedRead':
                    this.read = state;
                    break;
                case 'EntryStarred':
                    this.starred = state;
                    break;
                case 'EntryTagged':
                    var tagsElem = this.getElement('article-tags');
                    tagsElem.textContent = this.getAttribute('tags');
                    break;
                case 'DoRemoveEntry':
                    var self = this;
                    function callback() {
                        var feedContent = document.getElementById('feed-content');
                        feedContent.removeChild(self);
                    }
                    $(this).fadeOut(200, callback);
                    break;
                case 'DoCollapseEntry':
                    this.collapse(state, false);
                    break;
                case 'DoCollapseEntryAnimated':
                    this.collapse(state, true);
                    break;
            }
        </handler>

    </handlers>
</binding>


<binding id="searchbar"
         extends="chrome://global/content/bindings/textbox.xml#timed-textbox">
    <content>
        <children/>
        <xul:hbox class="searchbar-textbox textbox-input-box" flex="1">
            <xul:button class="search-scope-button" popup="_child"
                        tooltiptext="&searchScopeButton.tooltip;">
                <xul:menupopup anonid="searchbar-popup" position="after_start">
                      <xul:menuitem anonid="search-current"
                                    label="&searchCurrentView.label;"
                                    type="radio"
                                    value="0"/>
                      <xul:menuitem anonid="search-all"
                                    label="&searchAllFeeds.label;"
                                    type="radio"
                                    value="1"/>
                </xul:menupopup>
                <xul:image class="searchbar-button-image"/>
            </xul:button>

            <html:input class="searchbar-textbox textbox-input" anonid="input"
                        allowevents="true"
                        flex="1"
                        xbl:inherits="onfocus,onblur,value,type,maxlength,disabled,size,readonly,tabindex,accesskey"/>
        </xul:hbox>

        <xul:toolbarbutton anonid="searchbar-clearbutton"
                           class="searchbar-clearbutton"
                           hidden="true"/>
    </content>
    <implementation>
        <constructor>
            this.clearButton = document.getAnonymousElementByAttribute(this, 'anonid',
                                                                 'searchbar-clearbutton');
            var menuitem = document.getAnonymousElementByAttribute(this, 'value',
                                                                   this.searchScope);
            menuitem.setAttribute('checked', true);
            this.emptyText = menuitem.label;
        </constructor>

        <field name="clearButton">
            null
        </field>

        <property name="searchScope"
                  onget="return this.getAttribute('searchScope');">
            <setter>
                if (val != this.searchScope) {
                    this.setAttribute('searchScope', val.toString());
                    if (this.value)
                        performSearch();
                }

                return val;
            </setter>
        </property>

        <method name="clear">
            <body>
                this.value = '';
                this.clearButton.hidden = true;
                this.inputField.blur();
                finishSearch();
            </body>
        </method>

    </implementation>

    <handlers>
        <handler event="command">
            var target = event.originalTarget;
            var anonid = target.getAttribute('anonid');

            if (anonid == 'search-current' || anonid == 'search-all') {
                this.emptyText = target.label;
                this.searchScope = target.value;
            }
            else if (target == this) {
                this.clearButton.hidden = !this.value;
                async(performSearch);
            }
            else if (anonid == 'searchbar-clearbutton') {
                this.clear();
            }
        </handler>

        <handler event="blur" phase="capturing">
            if (!this.value)
                finishSearch();
        </handler>

        <handler event="keydown" keycode="VK_ESCAPE">
            this.clear();
            event.preventDefault();
        </handler>
    </handlers>
</binding>


<!-- Copied over from tree.xml. We have to copy the entire binding just to
     overwrite the mousedown handler. -->
<binding id="feedlist-treebody"
         extends="chrome://global/content/bindings/tree.xml#tree-base">
  <implementation>
    <constructor>
      if ("_ensureColumnOrder" in this.parentNode)
        this.parentNode._ensureColumnOrder();
    </constructor>

    <field name="_lastSelectedRow">
      -1
    </field>
  </implementation>
  <handlers>
    <!-- If there is no modifier key, we select on mousedown, not
         click, so that drags work correctly. -->
    <handler event="mousedown" clickcount="1">
    <![CDATA[
       if (event.button == 0) {
         var row = {};
         var col = {};
         var obj = {};
         var b = this.parentNode.treeBoxObject;
         b.getCellAt(event.clientX, event.clientY, row, col, obj);

         // save off the last selected row
         this._lastSelectedRow = row.value;
         if (row.value == -1)
           return;

        var item = this.parentNode.view.getItemAtIndex(row.value);
        if (item.localName == 'treeseparator')
          return;

         if (col.value && obj.value != "twisty") {
           if (col.value.cycler)
             b.view.cycleCell(row.value, col.value);
           else if (col.value.type == Components.interfaces.nsITreeColumn.TYPE_CHECKBOX) {
             if (this.parentNode.editable && col.value.editable &&
                 b.view.isEditable(row.value, col.value)) {
               var value = b.view.getCellValue(row.value, col.value);
               value = value == "true" ? "false" : "true";
               b.view.setCellValue(row.value, col.value, value);
             }
           }
           else
             if (!b.view.selection.isSelected(row.value)) {
               b.view.selection.select(row.value);
               b.ensureRowIsVisible(row.value);
             }
         }
       }
    ]]>
    </handler>

    <!-- On a click (up+down on the same item), deselect everything
         except this item. -->
    <handler event="click" button="0" clickcount="1">
    <![CDATA[
      var row = {};
      var col = {};
      var obj = {};
      var b = this.parentNode.treeBoxObject;
      b.getCellAt(event.clientX, event.clientY, row, col, obj);

      if (row.value == -1)
        return;

      var item = this.parentNode.view.getItemAtIndex(row.value);
      if (item.localName == 'treeseparator')
        return;

      if (obj.value == "twisty") {
        if (b.view.selection.currentIndex >= 0 &&
            b.view.isContainerOpen(row.value)) {
          var parentIndex = b.view.getParentIndex(b.view.selection.currentIndex);
          while (parentIndex >= 0 && parentIndex != row.value)
            parentIndex = b.view.getParentIndex(parentIndex);
          if (parentIndex == row.value)
            b.view.selection.select(parentIndex);
        }
        this.parentNode.changeOpenState(row.value);
        return;
      }

      if (! b.view.selection.single) {
        var augment = this._isAccelPressed(event);
        if (event.shiftKey) {
          b.view.selection.rangedSelect(-1, row.value, augment);
          b.ensureRowIsVisible(row.value);
          return;
        }
        if (augment) {
          b.view.selection.toggleSelect(row.value);
          b.ensureRowIsVisible(row.value);
          b.view.selection.currentIndex = row.value;
          return;
        }
      }

      /* We want to deselect all the selected items except what was
        clicked, UNLESS it was a right-click.  We have to do this
        in click rather than mousedown so that you can drag a
        selected group of items */

      if (!col.value) return;

      // if the last row has changed in between the time we
      // mousedown and the time we click, don't fire the select handler.
      // see bug #92366
      if (!col.value.cycler && this._lastSelectedRow == row.value &&
          col.value.type != Components.interfaces.nsITreeColumn.TYPE_CHECKBOX) {
        b.view.selection.select(row.value);
        b.ensureRowIsVisible(row.value);
      }
    ]]>
    </handler>

    <!-- double-click -->
    <handler event="click" clickcount="2">
    <![CDATA[
      var b = this.parentNode.treeBoxObject;
      var row = b.view.selection.currentIndex;
      if (row == -1 || !b.view.isContainer(row))
        return;

       var col = {};
       var obj = {};
       b.getCellAt(event.clientX, event.clientY, {}, col, obj);

       // Cyclers and twisties respond to single clicks, not double clicks
       if (!col.value.cycler && obj.value != "twisty")
         this.parentNode.changeOpenState(row);
    ]]>
    </handler>

  </handlers>
</binding>

</bindings>

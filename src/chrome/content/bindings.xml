<?xml version="1.0"?>

<!DOCTYPE bindings SYSTEM "chrome://brief/locale/brief.dtd">

<bindings id="brief"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:html="http://www.w3.org/1999/xhtml">

<!-- We use a seperate binding for article-header instead of making its content
     a part of the article binding, because we need the article-header element to be
     explicit. If it is anonymous, then we get wacky layout bugs related to mixing
     the explicit article-content element with an anonymous one. Damn you, XBL. -->
<binding id="article-header">
    <xbl:content xmlns="http://www.w3.org/1999/xhtml">
        <div class="expand-button"/>
        <div class="article-star" command="star"/>

        <div class="article-controls">
            <div class="mark-read" command="switchRead">
                <div class="mark-read-left" command="switchRead"/>
                <div class="mark-read-centre" command="switchRead"/>
                <div class="mark-read-right" command="switchRead"/>
            </div>
            <div class="delete-entry" command="delete"/>
            <div class="restore-entry" command="restore"/>
        </div>

        <div class="collapsed-article-subheader"/>

        <xbl:children/>

        <div class="article-subheader">
            <div class="article-date"/>
            <div class="article-authors"/>
            <div class="feed-name"/>
            <div class="article-tags"/>
        </div>

    </xbl:content>
</binding>


<binding id="article">
    <implementation>
        <constructor>
            // Some feeds include scripts that use document.write() which screw us up,
            // because we insert them dynamically after the page is loaded.
            document.write = function() { };

            var header = document.createElement('div');
            header.className = 'article-header';
            this.appendChild(header);
            this.header = header;

            // Build the content of the header and the subheader. Use innerHTML
            // instead of textContent, so that the entities are resolved.
            var titleElem = document.createElement('a');
            titleElem.className = 'article-title-link';
            titleElem.setAttribute('href', this.getAttribute('entryURL'));
            titleElem.setAttribute('command', 'open');
            titleElem.innerHTML = this.getAttribute('entryTitle') ||
                                  this.getAttribute('entryURL');
            header.appendChild(titleElem);

            var feedContent = document.getElementById('feed-content');
            var feedNameElem = this.getElement('feed-name');
            if (feedContent.hasAttribute('showFeedNames'))
                feedNameElem.innerHTML = this.getAttribute('feedName');

            var dateElem = this.getElement('article-date');
            dateElem.innerHTML = this.getAttribute('updatedString') ||
                                 this.getAttribute('dateString');

            var authorsElem = this.getElement('article-authors');
            authorsElem.innerHTML = this.getAttribute('authors');

            var tagsElem = this.getElement('article-tags');
            tagsElem.textContent = this.getAttribute('tags');

            var markReadElem = this.getElement('mark-read-centre');
            markReadElem.textContent = this.read ? gData.markUnreadString
                                                 : gData.markReadString;

            // article-content and article-title-link elements are created manually,
            // so that they are explicit instead of anynymous. This makes the context
            // menu work on them without the need of ugly and fragile hacks.
            // It also increases the chance of compatibility with various other
            // extensions which interact with the content.
            var contentElem = document.createElement('div');
            contentElem.className = 'article-content';
            contentElem.innerHTML = this.getAttribute('content');
            this.appendChild(contentElem);

            if (this.collapsed) {
                var collapsedSubheader = this.getElement('collapsed-article-subheader');
                collapsedSubheader.insertBefore(dateElem, null);
                collapsedSubheader.insertBefore(feedNameElem, null);
                $(contentElem).hide();
            }
        </constructor>

        <field name="header">
            null
        </field>

        <method name="getElement">
            <parameter name="aClassName"/>
            <body>
                return document.getAnonymousElementByAttribute(this.header, 'class',
                                                               aClassName);
            </body>
        </method>

        <method name="sendEvent">
            <parameter name="aEventName"/>
            <parameter name="aAsync"/>
            <body>
                var evt = document.createEvent('Events');
                evt.initEvent(aEventName, false, false);
                if (aAsync) {
                    var self = this;
                    setTimeout(function() { self.dispatchEvent(evt) }, 0);
                }
                else {
                    this.dispatchEvent(evt);
                }
            </body>
        </method>

        <method name="collapse">
            <parameter name="aState"/>
            <parameter name="aAnimate"/>
            <body>
                if (aState == this.collapsed)
                    return;

                var articleContent = this.getElementsByClassName('article-content')[0];
                var tagsElem = this.getElement('article-tags');
                var date = this.getElement('article-date');
                var feedName = this.getElement('feed-name');
                var self = this;

                if (aState) {
                    function finish() {
                        self.setAttribute('collapsed', true);

                        var collapsedSubheader = self.getElement('collapsed-article-subheader');
                        collapsedSubheader.insertBefore(date, null);
                        collapsedSubheader.insertBefore(feedName, null);
                    }

                    if (aAnimate) {
                        $(articleContent).animate({height: 'hide', opacity: 'hide'},
                                                  200, 'linear', finish);
                    }
                    else {
                        $(articleContent).hide();
                        finish();
                    }
                }

                else {
                    this.removeAttribute('collapsed');

                    var subheader = this.getElement('article-subheader');
                    subheader.insertBefore(date, this.getElement('article-authors'));
                    subheader.insertBefore(feedName, tagsElem);

                    function finish() {
                        self.sendEvent('EntryUncollapsed');
                    }

                    if (aAnimate) {
                        $(articleContent).animate({height: 'show', opacity: 'show'},
                                                  200, 'linear', finish);
                    }
                    else {
                        $(articleContent).show();
                        finish();
                    }
                }
            </body>
        </method>


        <property name="read"
                  onget="return this.hasAttribute('read')">
            <setter>
                if (val == this.read)
                    return;

                var markReadButton = this.getElement('mark-read-centre');

                if (val) {
                    this.setAttribute('read', 'true');
                    markReadButton.textContent = gData.markUnreadString;

                    if (this.hasAttribute('updated')) {
                        this.removeAttribute('updated');
                        var dateElement = this.getElement('article-date');
                        dateElement.innerHTML = this.getAttribute('dateString');
                    }
                }

                else {
                    this.removeAttribute('read');
                    markReadButton.textContent = gData.markReadString;
                }

                return val;
            </setter>
        </property>

        <property name="starred"
                  onget="return this.hasAttribute('starred')">
            <setter>
                if (val)
                    this.setAttribute('starred', 'true');
                else
                    this.removeAttribute('starred');

                return val;
            </setter>
        </property>

        <property name="collapsed"
                  onget="return this.hasAttribute('collapsed')"/>

    </implementation>

    <handlers>
        <handler event="click" button="0">
            <![CDATA[
            var target = event.originalTarget;
            var command = target.getAttribute('command');

            if (command) {
                switch (command) {
                case 'switchRead':
                    this.sendEvent('SwitchEntryRead');
                    break;
                case 'star':
                    if (this.hasAttribute('starred'))
                        this.sendEvent('ShowBookmarkPanel');
                    else
                        this.sendEvent('StarEntry');
                    break;
                case 'delete':
                    this.sendEvent('DeleteEntry');
                    break;
                case 'restore':
                    this.sendEvent('RestoreEntry');
                    break;
                }
            }
            else if (this.collapsed) {
                if (!target.hasAttribute(command))
                    this.collapse(false, true);
            }
            else {
                var headlinesView = document.getElementById('feed-content').
                                             hasAttribute('showHeadlinesOnly');
                var cls = target.className;

                if (headlinesView && (cls == 'expand-button' || cls == 'article-header'))
                    this.collapse(true, true);
            }
            ]]>
        </handler>


        <!-- Double-click marks the entry as read/unread. If the click targeted a
             command element, do nothing since it's too easy to do it accidentally.-->
        <handler event="click" button="0" clickcount="2">
            <![CDATA[
            var isCommandElement = event.originalTarget.hasAttribute('command');
            if (gData.doubleClickMarks && !isCommandElement)
                this.sendEvent('SwitchEntryRead');
            ]]>
        </handler>


        <!-- This event is how chrome sends us messages -->
        <handler event="ViewEvent">
            var state = (this.getAttribute('eventState') == 'true');
            switch (this.getAttribute('eventType')) {
                case 'EntryMarkedRead':
                    this.read = state;
                    break;

                case 'EntryStarred':
                    this.starred = state;
                    break;

                case 'EntryTagged':
                    let changedTag = this.getAttribute('changedTag');
                    let tags = this.getAttribute('tags');
                    tags = tags ? tags.split(', ') : [];

                    if (state) {
                        tags.push(changedTag);
                        tags.sort();
                    }
                    else {
                        let index = tags.indexOf(changedTag);
                        tags.splice(index, 1);
                    }

                    tags = tags.join(', ');
                    this.setAttribute('tags', tags);
                    this.getElement('article-tags').textContent = tags;
                    break;

                case 'DoRemoveEntry':
                    var self = this;
                    function callback() {
                        var feedContent = document.getElementById('feed-content');
                        feedContent.removeChild(self);
                    }
                    $(this).fadeOut(200, callback);
                    break;

                case 'DoCollapseEntry':
                    this.collapse(state, false);
                    break;

                case 'DoCollapseEntryAnimated':
                    this.collapse(state, true);
                    break;
            }
        </handler>

    </handlers>
</binding>


<binding id="searchbar"
         extends="chrome://global/content/bindings/textbox.xml#timed-textbox">
    <content>
        <children/>
        <xul:hbox class="searchbar-textbox textbox-input-box" flex="1">
            <html:input class="searchbar-textbox textbox-input" anonid="input"
                        allowevents="true"
                        flex="1"
                        xbl:inherits="onfocus,onblur,value,type,maxlength,disabled,size,readonly,tabindex,accesskey"/>
            <xul:image anonid="searchbar-glass-image"
                       class="searchbar-button-image"
                       onclick="getElement('searchbar').focus()"/>
            <xul:toolbarbutton anonid="searchbar-clearbutton"
                               class="searchbar-clearbutton"
                               hidden="true"/>
        </xul:hbox>
    </content>
    <implementation>
        <constructor>
            this.clearButton = document.getAnonymousElementByAttribute(this, 'anonid',
                                                                 'searchbar-clearbutton');
            this.glassImage = document.getAnonymousElementByAttribute(this, 'anonid',
                                                                 'searchbar-glass-image');
        </constructor>

        <field name="clearButton">
            null
        </field>

        <field name="glassImage">
            null
        </field>

        <field name="searchInProgress">
            false
        </field>

        <method name="clear">
            <body>
                this.value = '';
                this.clearButton.hidden = true;
                this.glassImage.hidden = false;
                this.inputField.blur();
                finishSearch();
            </body>
        </method>

    </implementation>

    <handlers>
        <handler event="command">
            var target = event.originalTarget;
            var anonid = target.getAttribute('anonid');

            if (target == this) {
                this.clearButton.hidden = !this.value;
                this.glassImage.hidden = !!this.value;
                async(performSearch);
            }
            else if (anonid == 'searchbar-clearbutton') {
                this.clear();
            }
        </handler>

        <handler event="blur" phase="capturing">
            if (!this.value)
                finishSearch();
        </handler>

        <handler event="keydown" keycode="VK_ESCAPE">
            this.clear();
            event.preventDefault();
        </handler>
    </handlers>
</binding>

</bindings>
